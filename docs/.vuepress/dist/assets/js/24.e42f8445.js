(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{224:function(t,v,s){"use strict";s.r(v);var e=s(0),a=Object(e.a)({},(function(){var t=this,v=t.$createElement,s=t._self._c||v;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("Tips")]),t._v(" "),s("p",[t._v("个人面试经历汇总")])]),t._v(" "),s("h2",{attrs:{id:"什么是闭包"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是闭包"}},[t._v("#")]),t._v(" 什么是闭包")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),s("ul",[s("li",[t._v("闭包就是能够读取其他函数内部变量的函数。")]),t._v(" "),s("li",[t._v("在js中那就是定义在函数内部的函数。")])])]),t._v(" "),s("h2",{attrs:{id:"原型链"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#原型链"}},[t._v("#")]),t._v(" 原型链")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),s("ul",[s("li",[t._v("原型：函数 prototype指向的对象就是原型（只有函数对象才有prototype属性）。")]),t._v(" "),s("li",[t._v("原型链：函数或对象的__proto__ 指向创建它的构造函数的原型对象。")])])]),t._v(" "),s("h2",{attrs:{id:"深拷贝"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#深拷贝"}},[t._v("#")]),t._v(" 深拷贝")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),s("ul",[s("li",[t._v("对象A = 对象B，因为对象B获取到的是对象A指向的是一个指针，A和B的指针指向同一个存储空间。因此对象B对指针指向的值进行变更，同事会影响到对象A。")]),t._v(" "),s("li",[t._v("深拷贝的实现方案：\n"),s("ul",[s("li",[t._v("obj = Object.assign({}, 目标对象)")]),t._v(" "),s("li",[t._v("obj = [...目标对象] //当前仅当目标对象只有一层")]),t._v(" "),s("li",[t._v("obj = JSON.parse(JSON.stringify(目标对象)) 缺点：会忽略undefined、symbol。不能序列化函数。不能解决循环引用的问题。")]),t._v(" "),s("li",[t._v("let obj = {} for (let key in 目标对象) { obj[key] = 目标对象[key]}")]),t._v(" "),s("li",[t._v("通过递归函数实现")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("function deepClone(target, map = new Map()) {\n    function isObj(o) {\n        return (typeof o === 'object' || typeof o === 'function') && o !== null;\n    }\n    if (isObj(target)) {\n        let cloneTarget = Array.isArray(target) ? [] : {};\n        if (map.get(target)) {\n            return map.get(target);\n        }\n        map.set(target, cloneTarget);\n        for (const key in target) {\n            cloneTarget[key] = deepClone(target[key], map);\n        }\n        return cloneTarget;\n    } else {\n        return target;\n    }\n}\n")])])])])])]),t._v(" "),s("h2",{attrs:{id:"首屏优化的方案"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#首屏优化的方案"}},[t._v("#")]),t._v(" 首屏优化的方案")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),s("ul",[s("li",[t._v("雪碧图（减少请求数）")]),t._v(" "),s("li",[t._v("骨架屏")]),t._v(" "),s("li",[t._v("图片懒加载")]),t._v(" "),s("li",[t._v("CDN（通过CDN引入资源和三方库）")]),t._v(" "),s("li",[t._v("缓存（强缓存和协商缓存）")]),t._v(" "),s("li",[t._v("服务器渲染（有利于SEO，减少浏览器的渲染压力）")]),t._v(" "),s("li",[t._v("vue-route懒加载 （vue-route的异步组件和webpack的代码分割）\n"),s("ul",[s("li",[t._v("const Foo = () => Promise.resolve({ /* 组件定义对象 */ })")]),t._v(" "),s("li",[t._v("import('./Foo.vue') // 返回 Promise")])])]),t._v(" "),s("li",[t._v("打包优化\n"),s("ul",[s("li",[t._v("使用webpack-bundle-analyzer进行分析")]),t._v(" "),s("li",[t._v("忽略不使用的引入")]),t._v(" "),s("li",[t._v("删除重复引入")]),t._v(" "),s("li",[t._v("hash缓存")]),t._v(" "),s("li",[t._v("代码分割")]),t._v(" "),s("li",[t._v("生产环境关闭")])])])])]),t._v(" "),s("h2",{attrs:{id:"元素居中的实现方案"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#元素居中的实现方案"}},[t._v("#")]),t._v(" 元素居中的实现方案")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),s("ul",[s("li",[t._v("margin：0 auto")]),t._v(" "),s("li",[t._v("position：absolute; top/bottom/left/rigth: 0;")]),t._v(" "),s("li",[t._v("position：absolute; left: 50%; margin-left: -50%的元素宽度")]),t._v(" "),s("li",[t._v("display：flex; align-content: center(竖直|多行) align-items: center(竖直|单行) justify-content: center(水平)")]),t._v(" "),s("li",[t._v("display：grid; align-items: center(竖直|单行) justify-content: center(水平)")])])]),t._v(" "),s("h2",{attrs:{id:"vue生命周期"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue生命周期"}},[t._v("#")]),t._v(" vue生命周期")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),s("ul",[s("li",[t._v("beforeCreate：在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。")]),t._v(" "),s("li",[t._v("created：在实例创建完成后被立即调用。")]),t._v(" "),s("li",[t._v("beforeMount:在挂载开始之前被调用：相关的 render 函数首次被调用。")]),t._v(" "),s("li",[t._v("mounted:虚拟dom生成后，并挂载到实例上去之后调用该钩子。")]),t._v(" "),s("li",[t._v("beforeUpdate:数据更新时调用，发生在虚拟 DOM 打补丁之前。")]),t._v(" "),s("li",[t._v("update:由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。")])])]),t._v(" "),s("h2",{attrs:{id:"vue双向绑定原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue双向绑定原理"}},[t._v("#")]),t._v(" vue双向绑定原理")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),s("p",[t._v("vue的数据双向绑定是通过数据劫持和发布-订阅者功能来实现的，实现步骤：")]),t._v(" "),s("ul",[s("li",[t._v("实现一个监听者Oberver来劫持并监听所有的属性，一旦有属性发生变化就通知订阅者")]),t._v(" "),s("li",[t._v("实现一个订阅者watcher来接受属性变化的通知并执行相应的方法，从而更新视图")]),t._v(" "),s("li",[t._v("实现一个解析器compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相对应的订阅者")])])]),t._v(" "),s("h2",{attrs:{id:"v-if和v-for的优先级"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#v-if和v-for的优先级"}},[t._v("#")]),t._v(" v-if和v-for的优先级")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),s("ul",[s("li",[t._v("在vue2.0当中，v-if和v-for可以并存在在一个dom上。")]),t._v(" "),s("li",[t._v("在vue2.0当中，v-for优先级高，v-if可以使用刀v-for的key值。")]),t._v(" "),s("li",[t._v("在vue3.0当中，v-if和v-for已经不能并存在同一个dom上。")])])]),t._v(" "),s("h2",{attrs:{id:"vue筛选器过滤多个参数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue筛选器过滤多个参数"}},[t._v("#")]),t._v(" vue筛选器过滤多个参数")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),s("ul",[s("li",[t._v("filter支持函数"+t._s(t._f("filterA")(t.message,"arg1",t.arg2))+"\n"),s("ul",[s("li",[t._v("filterA 被定义为接收三个参数的过滤器函数。")]),t._v(" "),s("li",[t._v("message 的值作为第一个参数")]),t._v(" "),s("li",[t._v("表达式 'arg1' 作为第二个参数")]),t._v(" "),s("li",[t._v("表达式 arg2 的值作为第三个参数。")])])]),t._v(" "),s("li",[t._v("filter支持多次过滤"+t._s(t._f("filterB")(t._f("filterA")(t.message)))+"\n"),s("ul",[s("li",[t._v("message作为filterA的参数")]),t._v(" "),s("li",[t._v("filterA的结果作为filterB的参数")])])])])]),t._v(" "),s("h2",{attrs:{id:"严格模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#严格模式"}},[t._v("#")]),t._v(" 严格模式")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),s("p",[t._v("严格模式是采用具有限制性JavaScript变体的一种方式，从而使代码脱离马虎模式/稀松模式/懒散模式模式。")]),t._v(" "),s("ul",[s("li",[t._v("严格模式通过抛出错误来消除了一些原有静默错误")]),t._v(" "),s("li",[t._v("严格模式修复了一些导致 JavaScript引擎难以执行优化的缺陷：有时候，相同的代码，严格模式可以比非严格模式下运行得更快")]),t._v(" "),s("li",[t._v("严格模式禁用了在ECMAScript的未来版本中可能会定义的一些语法")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('// 整个脚本都开启严格模式的语法\n"use strict";\n1，全局变量的显示声明\n2，严格模式限制了动态绑定，比如禁止使用with,创设eval的单独作用域\n3，严格模式下让你头痛的this关键字不能指向全局变量了\n4，不能重名：对象不能有重名属性，方法不能有重名形参\n5，对于arguments的限制，严格模式下不能对其赋值了，也不再跟踪参数的变化，arguments.callee也不允许使用\n6，函数必须声明在顶层，不允许在非函数代码块内声明函数\n7，试图删除不可删除的属性时会抛出异常\n8，严格模式禁止八进制数字语法\n9，ECMAScript 6中的严格模式禁止设置primitive值的属性\n10，在严格模式中一部分字符变成了保留的关键字\n')])])])]),t._v(" "),s("h2",{attrs:{id:"冒泡排序"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#冒泡排序"}},[t._v("#")]),t._v(" 冒泡排序")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),s("p",[s("router-link",{attrs:{to:"/Catalog/JavaScript/algorithm.html#冒泡排序",title:"算法"}},[t._v("算法")])],1)])])}),[],!1,null,null,null);v.default=a.exports}}]);